#!/usr/bin/env python3
# checkmk local security checks (stateful baseline/delta where useful)

import os
import re
import json
import time
import hashlib
import subprocess
from pathlib import path

# ----------------------------- config -----------------------------

# state-config
state_dir = path("/var/lib/check_mk_agent/security_watch")
state_file = state_dir / "state.json"

# sec_ssh_auth-config
sec_ssh_auth_isactive = 1
ssh_warn = 10
ssh_crit = 20

# sec_proc-config
sec_proc_isactive = 1
susp_proc_warn = int(os.getenv("cmk_susp_proc_warn", "1"))
susp_proc_crit = int(os.getenv("cmk_susp_proc_crit", "3"))

# suspicious process heuristics
susp_path_re = re.compile(r"(^|\s)(/tmp/|/dev/shm/|/var/tmp/)", re.IGNORECASE)
susp_name_re = re.compile(r"\b(kworkerd|kworker\d+|systemd--|dbusd--)\b", re.IGNORECASE)
deleted_re = re.compile(r"\(deleted\)", re.IGNORECASE)

# non-suspicious process allowlist (skip if matched)
allow_proc_name_re = re.compile(
    r"\b(docker|dockerd|containerd|containerd-shim|kubelet|kube-proxy|kubectl|k3s|minikube|"
    r"crio|podman|runc|pause|semaphore|ansible|prometheus|node_exporter|grafana|telegraf|"
    r"checkmk|cmk-agent|sshd|systemd|journald|rsyslogd)\b",
    re.IGNORECASE,
)

# container/runtime context markers in /proc/<pid>/cgroup
cgroup_container_re = re.compile(r"(docker-|kubepods|containerd|crio|libpod)", re.IGNORECASE)

# optional: known runtime binaries (extra filter)
allow_runtime_args_re = re.compile(
    r"(^|\s)(runc|containerd|containerd-shim|pause)(\s|$)", re.IGNORECASE
)

# sec_fstab-config
sec_fstab_isactive = 1
fstab_path = path("/etc/fstab")

# sec_cron-config
sec_cron_isactive = 1
cron_paths = [
    path("/etc/crontab"),
    path("/etc/cron.d"),
    path("/etc/cron.daily"),
    path("/etc/cron.hourly"),
    path("/etc/cron.weekly"),
    path("/etc/cron.monthly"),
    path("/var/spool/cron/crontabs"),
]

# sec_systemd_persist-config
sec_systemd_persist_isactive = 1

# sec_ssh_keys-config
sec_ssh_keys_isactive = 1
ssh_authorized_key_paths = [
    path("/root/.ssh/authorized_keys"),
    path("/home"),  # used as a base to scan /home/*/.ssh/authorized_keys
]

# sec_setuid-config
sec_setuid_isactive = 1

# sec_listen-config
sec_listen_isactive = 1
tcp_high_port_threshold = 40000
tcp_high_port_warn = 1
tcp_high_port_crit = 3

# sec_users-config
sec_users_isactive = 1

# sec_auth_files-config
sec_auth_files_isactive = 1
passwd_path = path("/etc/passwd")
shadow_path = path("/etc/shadow")
group_path = path("/etc/group")

# regex for ssh auth parsing
ip_re = re.compile(r"\bfrom\s+([0-9a-fA-F\.:]+)\b")
fail_re = re.compile(r"(failed password|invalid user|authentication failure)", re.IGNORECASE)

# ----------------------------- helpers -----------------------------

def load_state():
    try:
        with state_file.open("r") as f:
            return json.load(f)
    except Exception:
        return {}

def save_state(st):
    state_dir.mkdir(parents=True, exist_ok=True)
    tmp = state_file.with_suffix(".tmp")
    with tmp.open("w") as f:
        json.dump(st, f, indent=2, sort_keys=True)
    os.replace(tmp, state_file)

def local_line(code, svc, msg, perf=""):
    if perf:
        print(str(code) + " " + svc + " " + perf + " " + msg)
    else:
        print(str(code) + " " + svc + " - " + msg)

def run_cmd(cmd):
    p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return p.returncode, p.stdout, p.stderr

def sha256_file(p):
    h = hashlib.sha256()
    with p.open("rb") as f:
        while True:
            chunk = f.read(1024 * 1024)
            if not chunk:
                break
            h.update(chunk)
    return h.hexdigest()

def sha256_tree(paths_list):
    files = []
    for p in paths_list:
        if not p.exists():
            continue
        if p.is_file():
            files.append(p)
        elif p.is_dir():
            for fp in sorted(p.rglob("*")):
                try:
                    if fp.is_file():
                        files.append(fp)
                except OSError:
                    continue

    h = hashlib.sha256()
    uniq = sorted(set(files), key=lambda x: str(x))
    for fp in uniq:
        try:
            h.update(str(fp).encode())
            h.update(b"\0")
            h.update(sha256_file(fp).encode())
            h.update(b"\n")
        except Exception:
            h.update(str(fp).encode() + b"\0<unreadable>\n")
    return h.hexdigest(), len(uniq)

def check_integrity(st, key, svc, compute_fn):
    if "integrity" not in st:
        st["integrity"] = {}
    baseline = st["integrity"].get(key)
    current = compute_fn()

    if baseline is None:
        st["integrity"][key] = current
        local_line(1, svc, "baseline created (first run). verify and re-run if expected.")
        return

    if baseline != current:
        local_line(2, svc, "changed since baseline. investigate; update baseline if legitimate.")
    else:
        local_line(0, svc, "ok")

def read_text_file(p):
    try:
        return p.read_text(errors="ignore")
    except Exception:
        return ""

def read_proc_file(proc_path):
    try:
        with open(proc_path, "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except Exception:
        return ""

def pid_is_containerized(pid, cache):
    if pid in cache:
        return cache[pid]
    cg = read_proc_file("/proc/" + pid + "/cgroup")
    is_cont = False
    if cg and cgroup_container_re.search(cg):
        is_cont = True
    cache[pid] = is_cont
    return is_cont

# ============================= service blocks =============================

# ----------------------------- sec_ssh_auth -----------------------------

def run_journalctl_after_cursor(unit, cursor):
    cmd = ["journalctl", "--no-pager", "--output=json", "--show-cursor"]
    if unit:
        cmd += ["-u", unit]
    if cursor:
        cmd += ["--after-cursor", cursor]
    cmd += ["-n", "5000"]

    rc, out, err = run_cmd(cmd)
    if rc != 0:
        return None, None, "journalctl error: " + err.strip()[:200]

    new_cursor = None
    events = []
    for line in out.splitlines():
        if line.startswith("-- cursor: "):
            new_cursor = line.replace("-- cursor: ", "").strip()
            continue
        line = line.strip()
        if not line:
            continue
        try:
            obj = json.loads(line)
            msg = obj.get("message", "") or obj.get("MESSAGE", "")
            if msg:
                events.append(msg)
        except Exception:
            continue

    return events, new_cursor, None

def check_ssh_auth(st):
    if not sec_ssh_auth_isactive:
        local_line(0, "sec_ssh_auth", "disabled")
        return

    if "ssh" not in st:
        st["ssh"] = {}
    cursor = st["ssh"].get("cursor")

    events, new_cursor, err = run_journalctl_after_cursor("ssh", cursor)
    if err is not None:
        local_line(3, "sec_ssh_auth", "cannot read journal: " + err)
        return

    failures = 0
    ips = {}

    for msg in events:
        if fail_re.search(msg):
            failures += 1
            m = ip_re.search(msg)
            if m:
                ip = m.group(1)
                ips[ip] = ips.get(ip, 0) + 1

    if new_cursor:
        st["ssh"]["cursor"] = new_cursor

    uniq_ips = len(ips)
    top_ip = "-"
    if ips:
        top_ip = max(ips.items(), key=lambda kv: kv[1])[0]

    perf = "failures=" + str(failures) + ";" + str(ssh_warn) + ";" + str(ssh_crit) + "|uniq_ips=" + str(uniq_ips)

    if failures >= ssh_crit:
        local_line(2, "sec_ssh_auth", "ssh auth failures: " + str(failures) + ", uniq_ips=" + str(uniq_ips) + ", top=" + top_ip, perf=perf)
    elif failures >= ssh_warn:
        local_line(1, "sec_ssh_auth", "ssh auth failures: " + str(failures) + ", uniq_ips=" + str(uniq_ips) + ", top=" + top_ip, perf=perf)
    else:
        local_line(0, "sec_ssh_auth", "ok (failures=" + str(failures) + ")", perf=perf)

# ----------------------------- sec_proc -----------------------------

def check_suspicious_processes():
    rc, out, err = run_cmd(["ps", "-eo", "pid=,user=,pcpu=,pmem=,args="])
    if rc != 0:
        return None, None, "ps error: " + err.strip()[:200]

    suspicious = []
    cgroup_cache = {}

    for line in out.splitlines():
        line = line.strip()
        if not line:
            continue

        parts = line.split(None, 4)
        if len(parts) < 5:
            continue

        pid = parts[0]
        user = parts[1]
        pcpu = parts[2]
        pmem = parts[3]
        args = parts[4]

        # allowlist first
        if allow_proc_name_re.search(args):
            continue

        matched_path = bool(susp_path_re.search(args))
        matched_deleted = bool(deleted_re.search(args))
        matched_name = bool(susp_name_re.search(args))

        if not (matched_path or matched_deleted or matched_name):
            continue

        # ignore known runtime binaries if they only matched the "path" heuristic
        if allow_runtime_args_re.search(args) and not (matched_deleted or matched_name):
            continue

        # skip containerized processes to avoid noisy false positives
        if pid_is_containerized(pid, cgroup_cache):
            continue

        suspicious.append((pid, user, pcpu, pmem, args[:160]))

    return suspicious, len(suspicious), None

def check_proc(st):
    if not sec_proc_isactive:
        local_line(0, "sec_proc", "disabled")
        return

    susp_list, susp_count, err = check_suspicious_processes()
    if err is not None:
        local_line(3, "sec_proc", "cannot list processes: " + err)
        return

    examples = "-"
    if susp_count:
        ex = []
        for item in susp_list[:3]:
            ex.append(item[0] + ":" + item[1] + ":" + item[4])
        examples = "; ".join(ex)

    perf = "susp=" + str(susp_count) + ";" + str(susp_proc_warn) + ";" + str(susp_proc_crit)

    if susp_count >= susp_proc_crit:
        local_line(2, "sec_proc", "suspicious processes: " + str(susp_count) + " (examples: " + examples + ")", perf=perf)
    elif susp_count >= susp_proc_warn:
        local_line(1, "sec_proc", "suspicious processes: " + str(susp_count) + " (examples: " + examples + ")", perf=perf)
    else:
        local_line(0, "sec_proc", "ok (suspicious=" + str(susp_count) + ")", perf=perf)

# ----------------------------- sec_fstab -----------------------------

def check_fstab(st):
    if not sec_fstab_isactive:
        local_line(0, "sec_fstab", "disabled")
        return

    def fstab_hash():
        if not fstab_path.exists():
            return "missing"
        return sha256_file(fstab_path)

    check_integrity(st, "fstab_sha256", "sec_fstab", fstab_hash)

# ----------------------------- sec_cron -----------------------------

def check_cron(st):
    if not sec_cron_isactive:
        local_line(0, "sec_cron", "disabled")
        return

    def cron_hash():
        digest, nfiles = sha256_tree(cron_paths)
        return digest + ":" + str(nfiles)

    check_integrity(st, "cron_tree", "sec_cron", cron_hash)

# ----------------------------- sec_systemd_persist -----------------------------

def check_systemd_persist(st):
    if not sec_systemd_persist_isactive:
        local_line(0, "sec_systemd_persist", "disabled")
        return

    rc, out, err = run_cmd(["systemctl", "list-unit-files", "--type=service", "--state=enabled", "--no-pager"])
    if rc != 0:
        local_line(3, "sec_systemd_persist", "cannot list enabled units: " + err.strip()[:160])
        return

    units = []
    for line in out.splitlines():
        line = line.strip()
        if not line:
            continue
        if line.startswith("unit file") or line.startswith("0 unit files"):
            continue
        parts = line.split()
        if len(parts) >= 2 and parts[1] == "enabled":
            units.append(parts[0])

    units = sorted(set(units))
    prev = st.get("systemd_units_enabled")

    if prev is None:
        st["systemd_units_enabled"] = units
        local_line(1, "sec_systemd_persist", "baseline created (enabled units)")
        return

    new_units = sorted(set(units) - set(prev))
    st["systemd_units_enabled"] = units

    if new_units:
        local_line(2, "sec_systemd_persist", "new enabled units: " + ", ".join(new_units[:8]))
    else:
        local_line(0, "sec_systemd_persist", "ok")

# ----------------------------- sec_ssh_keys -----------------------------

def collect_authorized_keys():
    paths = [ssh_authorized_key_paths[0]]
    base = ssh_authorized_key_paths[1]

    try:
        if base.exists() and base.is_dir():
            for hp in base.glob("*/.ssh/authorized_keys"):
                paths.append(hp)
    except Exception:
        pass

    out = {}
    for p in paths:
        if p.exists():
            try:
                out[str(p)] = sha256_file(p)
            except Exception:
                out[str(p)] = "unreadable"
    return out

def check_ssh_keys(st):
    if not sec_ssh_keys_isactive:
        local_line(0, "sec_ssh_keys", "disabled")
        return

    current = collect_authorized_keys()
    prev = st.get("ssh_authorized_keys")

    if prev is None:
        st["ssh_authorized_keys"] = current
        local_line(1, "sec_ssh_keys", "baseline created (authorized_keys)")
        return

    changed = []
    for k in current:
        if prev.get(k) != current[k]:
            changed.append(k)

    removed = []
    for k in prev:
        if k not in current:
            removed.append(k)

    st["ssh_authorized_keys"] = current

    if changed or removed:
        msg_parts = []
        if changed:
            msg_parts.append("changed=" + str(len(changed)))
        if removed:
            msg_parts.append("removed=" + str(len(removed)))
        examples = (sorted(changed) + sorted(removed))[:6]
        local_line(2, "sec_ssh_keys", "authorized_keys delta (" + ", ".join(msg_parts) + "): " + ", ".join(examples))
    else:
        local_line(0, "sec_ssh_keys", "ok")

# ----------------------------- sec_setuid -----------------------------

def collect_setuid_files():
    rc, out, err = run_cmd(["find", "/", "-xdev", "-perm", "-4000", "-type", "f"])
    if rc != 0:
        return []
    files = []
    for ln in out.splitlines():
        ln = ln.strip()
        if ln:
            files.append(ln)
    return sorted(set(files))

def check_setuid(st):
    if not sec_setuid_isactive:
        local_line(0, "sec_setuid", "disabled")
        return

    current = collect_setuid_files()
    prev = st.get("setuid_files")

    if prev is None:
        st["setuid_files"] = current
        local_line(1, "sec_setuid", "baseline created (setuid list)")
        return

    new = sorted(set(current) - set(prev))
    st["setuid_files"] = current

    if new:
        local_line(2, "sec_setuid", "new setuid binaries: " + ", ".join(new[:6]))
    else:
        local_line(0, "sec_setuid", "ok")

# ----------------------------- sec_listen -----------------------------

def parse_listen_ports(ss_line):
    # try to extract local port from ss output line
    # examples: 0.0.0.0:22 or [::]:80 or 127.0.0.1:631
    m = re.search(r"(\[::\]|[0-9a-fA-F\.:]+):(\d+)\b", ss_line)
    if not m:
        return None
    try:
        return int(m.group(2))
    except Exception:
        return None

def collect_tcp_listeners():
    rc, out, err = run_cmd(["ss", "-lntp"])
    if rc != 0:
        return []
    listeners = []
    for line in out.splitlines():
        line = line.strip()
        if not line or line.lower().startswith("state"):
            continue
        if line.startswith("LISTEN") or line.startswith("listen"):
            listeners.append(line)
    return sorted(set(listeners))

def check_listen(st):
    if not sec_listen_isactive:
        local_line(0, "sec_listen", "disabled")
        return

    current = collect_tcp_listeners()
    prev = st.get("tcp_listeners")

    if prev is None:
        st["tcp_listeners"] = current
        local_line(1, "sec_listen", "baseline created (tcp listeners)")
        return

    new = sorted(set(current) - set(prev))
    st["tcp_listeners"] = current

    # high-port signal (current state, not only delta)
    high_ports = []
    for line in current:
        port = parse_listen_ports(line)
        if port is not None and port >= tcp_high_port_threshold:
            high_ports.append(port)
    high_ports = sorted(set(high_ports))

    new_count = len(new)
    high_count = len(high_ports)

    perf = "new=" + str(new_count) + ";;;|high_ports=" + str(high_count) + ";" + str(tcp_high_port_warn) + ";" + str(tcp_high_port_crit)

    if high_count >= tcp_high_port_crit:
        local_line(2, "sec_listen", "tcp listeners on high ports (>= " + str(tcp_high_port_threshold) + "): " + ", ".join([str(p) for p in high_ports[:8]]), perf=perf)
    elif high_count >= tcp_high_port_warn:
        local_line(1, "sec_listen", "tcp listeners on high ports (>= " + str(tcp_high_port_threshold) + "): " + ", ".join([str(p) for p in high_ports[:8]]), perf=perf)
    elif new:
        local_line(1, "sec_listen", "new tcp listeners: " + str(new_count) + " (example: " + new[0][:140] + ")", perf=perf)
    else:
        local_line(0, "sec_listen", "ok", perf=perf)

# ----------------------------- sec_users -----------------------------

def parse_passwd_users():
    users = {}
    if not passwd_path.exists():
        return users

    txt = read_text_file(passwd_path)
    for line in txt.splitlines():
        if not line or line.startswith("#"):
            continue
        parts = line.split(":")
        if len(parts) < 7:
            continue
        name = parts[0]
        uid = parts[2]
        gid = parts[3]
        home = parts[5]
        shell = parts[6]
        try:
            uid_i = int(uid)
            gid_i = int(gid)
        except Exception:
            continue
        users[name] = {"uid": uid_i, "gid": gid_i, "home": home, "shell": shell}
    return users

def check_new_users(st):
    if not sec_users_isactive:
        local_line(0, "sec_users", "disabled")
        return

    current = parse_passwd_users()
    prev = st.get("passwd_users")

    if prev is None:
        st["passwd_users"] = current
        local_line(1, "sec_users", "baseline created (/etc/passwd snapshot)")
        return

    new_names = sorted(set(current.keys()) - set(prev.keys()))
    new_human = []
    new_system = []

    for u in new_names:
        if current[u]["uid"] >= 1000 and u != "nobody":
            new_human.append(u)
        else:
            new_system.append(u)

    st["passwd_users"] = current

    if new_human:
        local_line(2, "sec_users", "new users (uid>=1000): " + ", ".join(new_human[:8]), perf="new=" + str(len(new_human)) + ";;;")
    elif new_system:
        local_line(1, "sec_users", "new system users: " + ", ".join(new_system[:8]), perf="new=" + str(len(new_system)) + ";;;")
    else:
        local_line(0, "sec_users", "ok", perf="new=0;;;")

# ----------------------------- sec_auth_files -----------------------------

def check_auth_files(st):
    if not sec_auth_files_isactive:
        local_line(0, "sec_auth_files", "disabled")
        return

    def auth_hash():
        parts = []
        for p in [passwd_path, shadow_path, group_path]:
            if not p.exists():
                parts.append(str(p) + "=missing")
            else:
                try:
                    parts.append(str(p) + "=" + sha256_file(p))
                except Exception:
                    parts.append(str(p) + "=unreadable")
        return "|".join(parts)

    check_integrity(st, "auth_files_sha256", "sec_auth_files", auth_hash)

# ============================= main =============================

def main():
    st = load_state()
    now = int(time.time())

    check_ssh_auth(st)
    check_proc(st)
    check_fstab(st)
    check_cron(st)
    check_systemd_persist(st)
    check_ssh_keys(st)
    check_setuid(st)
    check_listen(st)
    check_new_users(st)
    check_auth_files(st)

    st["meta"] = {"last_run": now}
    save_state(st)

if __name__ == "__main__":
    main()
